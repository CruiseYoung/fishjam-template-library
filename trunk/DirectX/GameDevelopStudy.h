#pragma once

/*********************************************************************************************************************
* 在大多数情况下，游戏循环是一个包括了大量状态的FSM(Finite State Machine，有限态计算机)
* 
*   游戏初始化 -> 游戏菜单 -> 开始游戏 -> 运行游戏 
*                   ↑                     |
*                   └----- 重新开始游戏<--┘
*                                         
*   while(game_state != GAME_EXIT)
*   {
*       switch(game_state)
*       {
*       case GAME_MENU:
*           game_stae = menu_choose();
*           break;
*       case GAME_STARTING:
*           ...
*           break;
*       case ...
*           break;
*       }
*   }
* 
*********************************************************************************************************************/

/*********************************************************************************************************************
* 游戏的编程技巧
*   1.不要怕使用全局变量 -- 参数压入和弹出堆栈需要耗时，造成函数体运行的时间小于函数调用所需的时间
*   2.使用内联功能，用空间换时间
*   3.尽量使用32位变量而不用8位变量或16位变量(即结构体中注意 char、short 等，尽量字节对齐)
*
* 碰撞检测
*   1.AKA边界圆/球的接触 -- 假设对象具有平均半径，通过检测半径是否重叠(距离)来检测两个多边形是否发生碰撞;
*     缺陷：可能使本来没有碰撞的对象误以为碰撞，也可能使碰撞被忽略。
*   2.边界箱 -- 利用近视对象本身的几何图形作为边界进行碰撞检测。通常是找出四条边(min_x,min_y,max_x,max_y)
*   3.点包含 -- 检测点是否在一个多边形内，如果是凸多边形，用半空间检测(每条边将空间分割成两部分，检测是否在半空间的内侧)
*
* 平铺显示
*   地图矩阵
*   稀疏矩阵
*
* 45度伪3D等角引擎
*   1.基于2D单元 -- 进行场景绘制时，从后向前画，保证远的对象被近的对象遮盖
*   2.基于屏幕，具有一些二维和三维碰撞体系
*   3.采用全三维数学运算，带一个相机视角
* 
*********************************************************************************************************************/
