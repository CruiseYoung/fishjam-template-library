add-in的后台线程必须是STA? 
System.Threading.Thread myThread = new xxx;
myThread.SetApartmentState(System.Threading.ApartmentState.STA);
myThread.Start();

CommandBars集合包含程序中的所有命令条，如：工具条和菜单条
CommandBar对象可以包含其它的 CommandBar 对象，这些对象是作为按钮或菜单命令来用的
每一个CommandBar都将通过CommandBarControls对象被引用
CommandBarControls又可以包含一组CommandBarControl对象
每一个CommandBarControl可以包含一个CommandBar对象，并可以通过它来存取控件属性

CommandBarControl可以有三种表现形式：
 弹出式(CommandBarPopup)：相当于菜单条的一个菜单项。
 组合框(CommandBarComboBox)：类似于工具条中组合框控件。它包括一个工具栏和紧接着工具栏的一个下拉箭头。单击该按钮，将显示出更多的带图标的菜单命令。
 按钮(CommandBarButton)：相当于标准的工具栏按钮，即带有图标的按钮。


template<typename T>
class QueryInterfaceForBackgroundThread
{
public:
	QueryInterfaceForBackgroundThread(IUnknown* pUnk)
	{
		HRESULT hr = E_FAIL;
		COM_VERIFY(CoMarshalInterThreadInterfaceInStream(__uuidof(T), pUnk, &m_spStream));
	}
	CComPtr<T>	GetInterface()
	{
		HRESULT hr = E_FAIL;
		if (!m_spInterface)
		{
			COM_VERIFY(CoGetInterfaceAndReleaseStream(m_spStream, __uuidof(T), (VOID**)&m_spInterface));
			m_spStream.Detach();
		}
		return m_spInterface;
	}
	operator CComPtr<T> () 
	{ 
		return GetInterface(); 
	}
	~QueryInterfaceForBackgroundThread()
	{
		
	}
private:
	CComPtr<IStream>	m_spStream;
	CComPtr<T>	m_spInterface;
};

Solution -> Prject -> ProjectItems -> ProjectItem
_CommandBars -> CommandBar -> CommandBarControls -> CommandBarControl(Popup) -> Command(AddControl)
Commands -> Command 

Bindings -- 快捷键，如 L"Text Editor::Ctrl+Shift+W, V"

HRESULT CConnect::CreateCommand(AddIn* pAddin, Commands2* pCommands2, CommandBar* pCmdBar, const CommandStruct* pCmd)
{
	CComPtr<EnvDTE::Command> pCreatedCommand;
	CComPtr<CommandBarControl> pCommandBarControl;

	HRESULT hr;
	COM_VERIFY_EXCEPT1(pCommands2->AddNamedCommand2(pAddin, 
		pCmd->Name, 
		pCmd->ButtonText,
		pCmd->ToolTip, 
		pCmd->bMSOButton, 
		pCmd->lBitmapId, 
		NULL, 
		EnvDTE::vsCommandStatusSupported+EnvDTE::vsCommandStatusEnabled,
		vsCommandStylePictAndText,
		vsCommandControlTypeButton,
		&pCreatedCommand), E_INVALIDARG);
		
	//Create New Command
	if(SUCCEEDED(hr) && (pCreatedCommand != NULL))
	{
		COM_VERIFY(pCreatedCommand->AddControl(pCmdBar, pCmd->lPos, (IDispatch**)&pCommandBarControl));
		if (pCmd->Bindings.bstrVal && pCmd->Bindings.bstrVal[0])
		{
			COM_VERIFY(pCreatedCommand->put_Bindings(pCmd->Bindings));
		}
	}
	else
	{
		//Already have same command, just find and Update Info
		CComPtr<EnvDTE::Command> pCurCommand;
		_bstr_t commandname = AddinString();
		commandname += pCmd->Name;
		COM_VERIFY(pCommands2->Item(_variant_t(commandname), 0, &pCurCommand));
		if (SUCCEEDED(hr) && !pCurCommand)
		{
			COM_VERIFY(pCurCommand->AddControl(pCmdBar, pCmd->lPos,
				(IDispatch**)&pCommandBarControl));
			
			if (pCmd->Bindings.bstrVal && pCmd->Bindings.bstrVal[0])
			{
				COM_VERIFY(pCurCommand->put_Bindings(pCmd->Bindings));
			}
		}
	}

	return hr;
}

DTE Service Provider
	1: ObjectExtenders
	2: SourceControl
	3: IVsProfferCommands
	4: _DTE
	5: IVsExtensibility
	6: IInternetSecurityManager
	7: IVsLinkedUndoTransactionManager
	8: IVsSolutionPersistence
	9: IVsRegisterProjectTypes
	10: IVsSolution
	11: IVsAddProjectItemDlg
	12: IVsRunningDocumentTable
	13: IVsInvisibleEditorManager
	14: IVsXMLMemberIndexService
	15: IVsUIShell
	16: IVsUIShellDocumentWindowMgr
	17: IVsExternalFilesManager
	18: IVsFileChangeEx
	19: IVsFileChange
	20: IVsIME
	21: IVsUIShellOpenDocument
	22: IVsShell
	23: IVsRegisterEditors
	24: IVsEnumHierarchyItemsFactory
	25: IVsMonitorSelection
	26: IVsTaskList
	27: IVsOutputWindow