#pragma once

#include <cppunit/extensions/HelperMacros.h>

/************************************************************************************************************
* 树(二叉树、完全二叉树、满二叉树、RB树和排序树)
*   树 -- 结点按分支关系组织起来的结构，必有一个特定的称为根(ROOT)的结点。一切具有层次关系的问题都可用树来描述。
*     结点的最大度数没有限制，结点无左、右之分
*   二叉树 -- 每个结点最多有两个子树(左子树和右子树)的有序树。第i层至多有2^(i-1)个结点；深度为k(k>=1)的二叉树
*     至多有 2^k-1 个结点，最少有k个结点
*   完全二叉树 -- 二叉树最多只有最后两层有度数小于2的结点，且最下层的结点都集中在该层的最左边的若干位置上。
*     具有n个结点的完全二叉树的深度为 int(log2n)+1。
*   满二叉树 -- 除了叶结点外每一个结点都有左右子叶且叶结点都处在最底层的二叉树
*   二叉排序树(RB树？) -- 根结点的权值大于（或小于）左子树中所有结点的权值；
*     根结点的权值小于（或大于）其右子树中所有结点的权值。
* 
*  从第一层的结点(即根)开始，由下而上，由左及右，按顺序结点编号，便得到二叉树的一个顺序表示。
*  二叉树遍历 -- 按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问且只被访问一次。通常用递归实现。
*    先(根次)序遍历,NLR -- 访问根；按先序遍历左子树；按先序遍历右子树
*    中(根次)序遍历,LNR -- 按中序遍历左子树；访问根；按中序遍历右子树
*    后(根次)序遍历,LRN -- 按后序遍历左子树；按后序遍历右子树；访问根
*    层次遍历 -- 按照层次访问，通常用队列来做。访问根，访问子女，再访问子女的子女
*    如：    A
*           / \
*          B   C
*         /   / \
*        D   E   F
*       先序遍历：A、B、D、C、E、F
*       中序遍历：D、B、A、E、C、F
*       后序遍历：D、B、E、F、C、A
*       层次遍历: A、B、C、D、E、F
*     由中序 + 前序/后序遍历序列 可以唯一确定一棵二叉树
*
*  二叉链表：以二叉树的先序序列为输入构造，加入虚结点以示空指针的位置(包括叶子节点)。
*    如上是：A、B、D、O、O、O、C、E、O、O、F、O、O
* 
*  堆 -- 完全二叉树中所有非终结点的值均不大于（或不小于）其左右孩子结点的值，采用层次遍历方式？
*************************************************************************************************************/


/************************************************************************************************************
* map -- 由{键，值}对组成的集合，以某种作用于键对上的谓词排列
* multimap -- 允许键对有相等的次序的映射
*
* 标准关联容器 set, multiset, map, multimap 内部采用的就是一种非常高效的平衡检索二叉树：红黑树，
* 也成为RB树(Red-Black Tree)。RB树的统计性能要好于一般的平衡二叉树。
* 
* 插入、删除、查找效率高(查找次数是 log2N )；每次insert之后，以前保存的iterator不会失效；
* 关联容器提供对数时间复杂度的lower_bound、upper_bound和equal_range成员函数 -- 用于 ItemCache?
* 
* 表达式 m[k] = v;( operator[] 被设计为简化“添加或更新”功能)
*   检查键k是否已经在map里。如果不，就以v作为它的对应值添加上。如果k已经在map里，它的关联值被更新成v。
*   对韩复杂类型值的map，避免频繁通过[]去查询已有数据，否则会有性能问题
*
*   
* 
************************************************************************************************************/

#if 0
    //map 中应该存在的 select1st 和 select2nd -- 在SGI的实现中存在，但不可移植
    map<int, string> m;
    // 把所有的map键写到cout
    transform(m.begin(), m.end(),ostream_iterator<int>(cout, "\n"),select1st<map<int, string>::value_type>());
    // 建立一个vector，把map中所有的值拷贝进去
    vector<string> v;
    transform(m.begin(), m.end(), back_inserter(v),select2nd<map<int, string>::value_type>());
#endif 

class CSTLMapTester : public CPPUNIT_NS::TestFixture
{
public:

    CPPUNIT_TEST_SUITE( CSTLMapTester );
    CPPUNIT_TEST( testAddData );
    CPPUNIT_TEST( test_map_sort );
    CPPUNIT_TEST_SUITE_END();

    //当“增加”被执行时，insert比operator[]更高效 -- 参见 Effective STL 规则 24
    //当“更新”被执行时，operator[]比insert更高效
    void testAddData();
    void test_map_sort();

    DECLARE_DEFAULT_TEST_CLASS(CSTLMapTester);
};
