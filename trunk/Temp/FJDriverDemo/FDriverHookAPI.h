#ifndef F_DRIVER_HOOK_API_H
#define F_DRIVER_HOOK_API_H
#pragma once

//[原创开源]在WIN7 X64上Hook Shadow SSDT  --  http://www.m5home.com/bbs/thread-6963-1-1.html


//#include "WindowsTypes.h"

//注意：2个driver先后hook ssdt并且如果先后unload通常是灾难之源 -- 如果发现地址不在原来的位置(win32k.sys?)的话，不进行hook？

// nt!_KTHREAD -- X64下有这个全局变量(什么东西？线程? )，里面可以找到ServiceTable ？


//Tommy 的专栏 -- http://blog.csdn.net/whf727/article/details/4986575
//KeServiceDescriptorTable 结构及修改内存保护写的方法 --   http://www.3600safe.com/?post=94

//bf84d8de  win32k!FastWindowFromDC 
//bf8c30bc  win32k!_WindowFromDC 

//到SSDT Shadow表中的函数定义和参数说明 -- WRK(2003的源码)
//  WRK(Windows Research Kernel) -- 微软为高校操作系统课程提供的可修改和跟踪的操作系统教学平台。
//  给出了Windows这个成功的商业操作系统的内核大部分代码，可以对其进行修改、编译，并且可以用这个内核启动Windows操作系统。
//  检查导入表符号的小工具 -- 静态分析PE文件的导入表，挨个对导入表中的符号，去导入文件的导出表中去搜索(参考WRK)

//问题：给出来的表示错误的
//  x64里用windbg查看SSDT/Shadow SSDT -- http://hi.baidu.com/ithurricane/item/4cabc91964d1460de75c3634
//     查看SSDT函数的方法(Win7 x64测试似乎可以) -- ln (dwo(nt!KiServiceTable + 4*index)>>4) + nt!KiServiceTable
//     查看Shadow SSDT的方法(Win7 x64测试不对) -- ln win32k!W32pServiceTable+((poi(win32k!W32pServiceTable+4*index)&0x00000000`ffffffff)>>4)-10000000
//  获取函数地址的公式是：dwo(nt!KiServiceTable+n)+nt!KiServiceTable（n=0,1,2…）。
//  http://bbs.dbgtech.net/forum.php?mod=viewthread&tid=360

//Windows WIN32K.SYS System Call Table (NT/2000/XP/2003/Vista/2008/7)
//  http://j00ru.vexillium.org/win32k_syscalls/
//  http://j00ru.vexillium.org/win32k_x64/


//Win7 64位对于未有认证签名的驱动程序进行了限制安装 -- 启动时F8后可以选择“禁用驱动程序签名强制”或通过bcdedit更改
// on x86,we use Hook shadowSSDT; on x64,we use inline hook in user-mode;

//TODO: Depends 查看 ntkrnlpa.exe + win32k.sys 并比较索引值
//SoftICE for Windows NT/2000的ntcall命令可以将这些System Service显示出 -- http://dev.21tx.com/2005/03/14/12553.html
//读取硬盘上的ntoskrnl.exe文件，根据export table定位原始的SSDT，再用物理内存与虚拟内存映射的办法转换，得到系统中SSDT的位置

/******************************************************************************************************************
* 在Windows操作系统中，消息钩子（通过SetWindowsHookEx设置）只会当前的桌面上的窗口有效，
* 所以可以建立一个安全桌面，用于运行需要严密保护的进程，这样非本桌面上运行的程序无法通过消息钩子的方式来
* 获取需要保护进程窗口的信息，达到了保护目标进程窗口的目的(360保险箱和金山密保 的 安全桌面功能 )
******************************************************************************************************************/

/******************************************************************************************************************
* PatchGuard -- 64位系统中的内核补丁保护程序, 有应用或驱动尝试修改核心组件，就会产生 CRITICAL_STRUCTURE_CORRUPTION(0x109)蓝屏错误
*   保护下列组件
*     系统模块 (ntoskrnl.exe、ndis.sys、hal.dll)
*     系统服务分派表 (SSDT, System Service Dispatch Table -- KeServiceDescriptorTable)
*     全局描述符表 (GDT -- Global Descriptor Table)
*     中断描述符表 (IDT -- Interrupt Descriptor Table)
*     Processor MSRs (syscall)
*     使用不是由内核分配的内核堆栈(Using kernel stacks that are not allocated by the kernel)
*     修补内核的任何部分	 -- Patching any part of the kernel (detected only on AMD64-based systems) 
*     TODO：不检查 inline hook 和 Shadow SSDT ?
* 
*  禁用PatchGuard -- 进行双机调试且在被调试机启动时就挂载上内核调试器，PatchGuard就不会被启用。
*
*   PatchGuard可能是所有操作系统中第一个验证内核镜像、内存及 MSR并检查系统是否受到损害的组件。
*     为防止第三方内核模块禁用内核补丁保护，其初始化和操作模式已高度模糊化并随机化，试图分析 PatchGuard将是徒劳无功的。
*   PatchGuard 原理 -- 
*     1.初始化(使用了很多的错误引导迷惑对此好奇的人士)
*     	if (KiDivide6432(KiTestDividend, 0xCB5FA3) != 0x5EE0B7E5){ KeBugCheck(UNSUPPORTED_PROCESSOR); }
*     2.实际运行时，会产生除法溢出错误异常，由 KiDivideErrorFault 继续处理， 启动PatchGuard的初始化过程。
*     3.选定随机化的池标签及数位大小并分配内存，然后使用随机密钥对 PatchGuard 进行加密并复制到该内存
******************************************************************************************************************/

//  http://www.microsoft.com/whdc/driver/kernel/64bitPatching.mspx
//  http://uninformed.org/index.cgi?v=8&a=5
//  http://www.mcafee.com/cn/resources/reports/rp-defeating-patchguard.pdf
//  DEP(基于硬件的数据执行保护) -- 

/******************************************************************************************************************
* 驱动级的 HOOK API( 通过更改 SSDP 中的函数地址来 Hook) -- 
*   注意先看该作者的其他下载。http://download.csdn.net/detail/jyw1111/5275135
*   缺点：可能被反病毒软件作为 rootkit 提醒
*
* 软中断：
*   Win2K -- int 2eh
*   WinXp -- sysenter
*
* Native API：
*   ntdll.dll -- Native API 的接口，通过软中断方式将调用传到内核来调用系统服务，但本身属于Ring 3。
*     函数名一般是对应Win32API前加 Nt 两个字母。
*     1.把对应的功能编号存入eax寄存器,
*     2.使用 SYSENTER 指令(早期使用触发 Int 2e 中断的方式)引发"自陷"
*     3.KiSystemService 内核处理程序运行
*     4.在SDT里找到功能编号的对应函数位置，并调用
*       SDT在系统中一共有4个()：
*       0.SSDT -- 位于 ntoskrnl.exe 或 ntkrnlpa.exe 中，记录了系统关键功能的位置,涉及文件操作,注册表操作,进程操作等。TODO：为什么有两个？区别？
*       1.Shadow SSDT -- 位于 win32k.sys 中， 记录了和用户与图形界面有关的功能。
*       2.3 -- 预留的SDT，即有人工创造SDT的可能，不过基本上没有意义
*     5.Object Hook -- 更底层的接口，不过已经很难控制了
*
* ntkrnlpa.exe (SSDT?) -- Kernel32.Dll 的内核实现
* ntkrnlmp.exe ?
* ntoskrnl.exe -- Windows执行体组件
* win32k.sys (Shadow SSDT?) -- User32.dll + Gdi32.DLL 的内核实现
*   将GUI的实现放入内核模式，会增大系统不稳定的几率。但会大大提高图形处理的运行效率。
*
* KeUserModeCallBack -- 从R0调用位于Ring3的函数(系统所有的消息钩子回调都是利用该函数完成的)
* 
* http://bbs.pediy.com/showthread.php?t=149861&highlight=NtGdiBitBlt
* NtGdiBitBlt / NtGdiAlphaBlend / NtGdiCancelDC / NtGdiColorCorrectPalette / NtGdiConsoleTextOut / NtGdiCreateColorSpace /NtGdiCreateColorTransform
* NtGdiGetDCPoint / NtGdiGetDCObject
*
 

NtUserPrintWindow
NtGdiDdLock
NtGdiPlgBlt
NtGdiMaskBlt
NtGdiTransparentBlt
NtGdiCreateDIBSection
NtGdiAlphaBlend
NtGdiGetPixel
NtUserSendInput
NtOpenSection
NtGdiBitBlt，NtGdiMaskBlt，NtGdiPlgBlt，NtGdiStretchBlt。NtUserBuildHwndList，NtUserFindWindowEx
******************************************************************************************************************/

/******************************************************************************************************************
*      System Services Descriptor Table
* SSDT(System Service Descriptor Table) -- 系统服务描述表，是各个系统服务号的 索引 => 对应系统服务函数的地址。
*   把Ring3的Win32 API和Ring0的内核API联系起来。
*   通过修改此表的函数地址可以对常用windows函数及API进行hook，从而实现对一些关心的系统动作进行过滤、监控的目的.
*   TODO: 怎么得到一个函数的SSDT索引号(dumpbin 或 depends ?)
*         http://www.cnblogs.com/nlsoft/archive/2013/04/02/2994628.html
* Shadow SSDT(Shadow System Services Descriptor Table) -- 管图形、用户相关的函数(gdi32.dll,user32.dll)
*   注意：
*   1.win32k.sys不是常在内存的，如果不是GUI线程，Shadow SSDT 地址无效 -- 在GUI线程中DeviceIoControl即可;
*   2.通常需要附加的进程是 csrss.exe ? GetCsrPid()
*   3.使用MDL映射一块不分页内存，设置成可以写入，常驻在物理内存(参见 RegmonMapServiceTable)
*     TODO:通过 #pragma LOCKEDCODE 声明变量即可？
*   4.GDI的很多函数会操作 _pGdiSharedHandleTable 表?
*
* KeServiceDescriptorTable -- 系统预定义的保存SSDT信息的变量，可通过extern后访问，如 WinDbg 中: dd KeServiceDescriptorTable
* KeServiceDescriptorTableShadow -- 为了做 Shadow SSDT Hook 而定义的，系统中不存在，可以通过 KeServiceDescriptorTable 来定位。
* 

* 对SSDT进行Hook的过程
*   1.关闭CR0写保护(改变CR0寄存器的WP位)；
*   2.1.Hook Shadow SSDT 之前，必须将进程上下文切换到CSRSS进程
*   2.2.用新的函数地址替换原来SSDT中的函数地址
*   3.恢复CR0写保护
* 
* Shadow SSDT 中函数名定位：
*   1.可以解析pdb得到，但比较麻烦(已有 获取shadow地址和函数名称的工具 )
*     SymInitialize -> SymSetSearchPath -> SymLoadModule -> SymGetSymFromName
*   2.同一个版本的系统调用号一样，经过测试后可以直接写死
*     
* Hook 检查(避免和别人的Hook冲突或安全检查)
*   1.查看 OldFunc 的函数地址是否在win32k的模块里
* 
* 窗口保护 NtUserFindWindowEx、NtUserGetForegroundWindow、NtUserBuildHwndList、NtUserQueryWindow、
*          NtUserWindowFromPoint、NtUserSetParent、NtUserPostMessage、NtUserMessageCall、
*          NtUserSetWindowLong、NtUserShowWindow、NtUserDestroyWindow、NtUserCallHwndParamLock
* 模拟按键 NtUserSendInput
* 获取键盘按键状态 NtUserGetAsyncKeyState
* 打开安全桌面 NtUserOpenDesktop
* 将虚假按键还原成真实的按键 NtUserTranslateMessage
* 截屏保护 NtGdiStretchBlt
******************************************************************************************************************/

/******************************************************************************************************************
* 系统进程分析
*   csrss.exe -- Windows子系统服务器进程, 会保存所有进程的句柄，
*     Console窗体的 ScrollDC 等API需要Hook这个进程才行？
*     win32!RawInputThread 通过 GUID_CLASS_KEYBOARD 获得键盘设备栈中PDO的符号连接名
*   System -- 系统进程，在系统启动时创建。
*     当驱动加载的时候，系统进程启动新的线程，调用对象管理器，创建一个驱动对象(DRIVER_OBJECT)，然后调用其 DriverEntry 
******************************************************************************************************************/

/******************************************************************************************************************
*             Ring3(kernel32)                    |   Native API(ntdll!)     |       Ring0(nt!)          |
* ------------------------------------------- SSDT (WinXP 284) -----------------------------------------|
* OpenProcess                                    | NtOpenProcess            | NtOpenProcess             |
* NtDuplicateObject                              |                          |                           |
* CreateThread/CreateRemoteThread                | NtCreateThread           | CreateThread              |
* OpenThread                                     |                          | NtOpenThread              |
* WriteProcessMemory                             | NtWriteVirtualMemory     | NtWriteVirtualMemory      |

* ------------------------------------- Shadow SSDT (WinXP 667)-----------------------------------------|
* BitBlt                                         |                          | NtGdiBitBlt               |
* CreateDC										 |                          | NtGdiOpenDCW              |
* DeleteDC                                       |                          | NtGdiDeleteObjectApp      |
* DestroyWindow                                  |                          | NtUserDestroyWindow       |
* EnableWindow                                   |                          | NtUserCallHwndParamLock   |
* EnumWindows                                    |                          | NtUserBuildHwndList       |
* FindWindow                                     |                          | NtUserFindWindowEx        |
* GetForegroundWindow                            |                          | NtUserGetForegroundWindow |
* GetWindowThreadProcessId                       |                          | NtUserQueryWindow         |
* PostMessage                                    |                          | NtUserPostMessage         |
* SendMessage                                    |                          | NtUserMessageCall         |
* SetParent                                      |                          | NtUserSetParent           |
* SetWindowLong                                  |                          | NtUserSetWindowLong       |
* ShowWindow                                     |                          | NtUserShowWindow          |
* StretchBlt                                     |                          | NtGdiStretchBlt           | 
* WindowFromDC                                   |                          | NtUserCallOneParam        |
* WindowFromPoint                                |                          | NtUserWindowFromPoint     |
*                                                |                          | NtUserCallTwoParam        |
******************************************************************************************************************/
//#define TWOPARAM_ROUTINE_SETDCBRUSHCOLOR    0xfffd0046
//#define NtUserSetDCBrushColor(hbr, crColor) (COLORREF)NtUserCallTwoParam((DWORD)(hbr), (DWORD)crColor, TWOPARAM_ROUTINE_SETDCBRUSHCOLOR)

#ifdef __cplusplus
extern "C" {
#endif

#define SSDT_API_CALL_ENTER(x) (InterlockedIncrement(&x))
#define SSDT_API_CALL_LEAVE(x) (InterlockedDecrement(&x))

//SSDT表结构 -- 32/64 通用， func = (PBYTE)Base+Base[index];
typedef struct _SYSTEM_SERVICE_TABLE { 
	// PNTPROC ServiceTable;
	PVOID *ServiceTable;					//SSDT在内存中的基地址(数组，其每一个的元素就是各个Rin0的函数)
	PULONG CounterTable;					// array of usage counters, 包含着 SSDT 中每个服务被调用次数计数器的数组。这个计数器一般由sysenter 更新
	//ULONG NumberOfServices;				    //SSDT项的个数
	SIZE_T NumberOfServices;				    //SSDT项的个数
	PBYTE ArgumentsTable;					//TODO:实际上是参数个数(ParamTableBase)? 包含每个系统服务参数字节数表的基地址-系统服务参数表
} SYSTEM_SERVICE_TABLE, *PSYSTEM_SERVICE_TABLE;

//系统中的4个SSDT表
typedef struct _SERVICE_DESCRIPTOR_TABLE
{
	SYSTEM_SERVICE_TABLE ntoskrnl;  // ntoskrnl.exe(native api，即 SSDT, KeServiceDescriptorTable )
	SYSTEM_SERVICE_TABLE win32k;    // win32k.sys (gdi/user support, shadow SSDT)
	SYSTEM_SERVICE_TABLE Table3;    // not used
	SYSTEM_SERVICE_TABLE Table4;    // not used
}SYSTEM_DESCRIPTOR_TABLE, PSYSTEM_DESCRIPTOR_TABLE;

typedef struct _SCROLL_DATA
{
	int dy;
	RECT rcScroll;
} SCROLL_DATA, *PSCROLL_DATA;
#pragma push(0)

SYSTEM_SERVICE_TABLE *GetServiceDescriptorShadowTableAddress();
//int GetNtGdiBitBltIndex(SYSTEM_SERVICE_TABLE *p);

void InstallCopyProtectHook(HANDLE hProcess, HWND hWndDesktop);
void UnInstallScrollHook(void);

typedef struct _SYSTEM_HANDLE_INFORMATION{
	ULONG ProcessID;                //进程的标识ID
	UCHAR ObjectTypeNumber;         //对象类型
	UCHAR Flags;                    //0x01 = PROTECT_FROM_CLOSE,0x02 = INHERIT
	USHORT Handle;                  //对象句柄的数值
	PVOID  Object;                  //对象句柄所指的内核对象地址
	ACCESS_MASK GrantedAccess;      //创建句柄时所准许的对象的访问权
}SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_INFORMATION Information[1];
}SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;


//typedef enum _OBJECT_INFORMATION_CLASS{
//	ObjectBasicInformation,
//	ObjectNameInformation,
//	ObjectTypeInformation,
//	ObjectAllInformation,
//	ObjectDataInformation
//}OBJECT_INFORMATION_CLASS, *POBJECT_INFORMATION_CLASS;

#ifdef __cplusplus
}
#endif


#if 0
//SSDT表结构
typedef struct _ServiceDescriptorTable {
	PULONG ServiceTableBase;			//System Service Dispatch Table 的基地址  
	PULONG ServiceCounterTableBase; 
	//包含着 SSDT 中每个服务被调用次数的计数器。这个计数器一般由sysenter 更新
	ULONG NumberOfServices;				//由 ServiceTableBase 描述的服务的数目
	PBYTE ParamTableBase;				//TODO:实际上是参数个数? 包含每个系统服务参数字节数表的基地址-系统服务参数表  
}*PServiceDescriptorTable;
//由SSDT索引号获取当前函数地址
//NtOpenProcess  [[KeServiceDescriptorTable]+0x7A*4]
extern "C" PServiceDescriptorTable KeServiceDescriptorTable;


或者(似乎没有看到 _SERVICE_DESCRIPTOR_TABLE 的定义)
typedef struct _SERVICE_DESCRIPTOR_TABLE *PSERVICE_DESCRIPTOR_TABLE;
xtern PSERVICE_DESCRIPTOR_TABLE KeServiceDescriptorTable;
#endif

#endif //F_DRIVER_HOOK_API_H

