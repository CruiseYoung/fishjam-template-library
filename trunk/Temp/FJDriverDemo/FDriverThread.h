#ifndef F_DRIVER_THREAD_H
#define F_DRIVER_THREAD_H

/******************************************************************************************************************
* KSPIN_LOCK -- 自旋锁 ? 
*   KeInitializeSpinLock
*   
* KEVENT -- 
*   KeInitializeEvent
******************************************************************************************************************/

/******************************************************************************************************************
* 多线程同步
*   ExAcquireFastMutex/ExReleaseFastMutex -- 获取/释放一个快速互斥体
*
* 考虑代码的调用者在哪里 -- 处理函数可重入性 和 考虑运行中断级别
*   DriverEntry/DriveUnload -- 由系统进程的单一线程调用，不会出现多线程同时调用的情况
*   各种分发函数、完成函数、NDIS回调函数 -- 可能被多线程同时调用
*
* 中断级(IRQL，中断优先级?) -- 通常具有比较复杂功能的内核API(如 IoCreateFile)都要求必须在Passive级执行
*   PASSIVE_LEVEL(0), DISPATCH_LEVEL(2), 设备中断请求级别 DIRQL(4)，
*   规则：
*     0.执行在高于或等于 DISPATCH_LEVEL 级的代码不可以引发页故障 ( PAGED_CODE 宏 可以帮助检查，不满足则会引发断言?)
*     1.如果在调用路径上没有特殊的情况(导致中断级的提高或降低)，则一个函数执行时的中断级和它的调用源的中断级相同
*     2.如果在调用路径上有获取自旋锁，则中断级随之升高；如果调用路径上有释放自旋锁，则中断级随之下降
*     3.当前代码运行的中断级(如DISPATCH_LEVEL) 和 需要调用函数能运行的中断级(如PASSIVE_LEVEL)不一样时，不能使用API改变当前中断级。
*       但可以：
*       a.生成一个线程专门去执行指定中断级的代码
*   主要调用源的运行中断级
*     DriverEntry/DriveUnload	-- PASSIVE_LEVEL
*     各种分发函数				-- PASSIVE_LEVEL
*     完成函数、NDIS回调函数	-- DISPATCH_LEVEL
******************************************************************************************************************/


/******************************************************************************************************************
* 中断：IRQ 和 INT
*   如 _asm int 3    -- 激发一个中断号为3的软件中断(即设置一个断点)
*   中断处理函数的首地址保存在 IDT(中断描述符表) 中，每个中断号只有最后设置的中断处理函数有效
*   在IOAIPC出现后，可以修改IRQ号到中断号的对应关心，
******************************************************************************************************************/

#endif //F_DRIVER_THREAD_H