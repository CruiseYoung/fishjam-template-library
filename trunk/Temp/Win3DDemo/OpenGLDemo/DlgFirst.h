// This file was generated by WTL Dialog wizard 
// DlgButtons.h : Declaration of the CDlgFirst

#pragma once

#include "resource.h"       // main symbols
#include "DialogResizeEx.h"
#include <ftlOpenGL.h>

// CDlgFirst

class CMyOpenGLWnd : public CWindowImpl<CMyOpenGLWnd, CWindow, CFrameWinTraits>
    , public FTL::CFOpenGLWindowImpl<CMyOpenGLWnd>
    , public CUpdateUI<CMyOpenGLWnd>
    //, public CMessageFilter
    , public CIdleHandler
{
public:
    DECLARE_WND_CLASS_EX(TEXT("FTLOpenGLWindow"), CS_VREDRAW | CS_HREDRAW | CS_OWNDC, -1)
    //DECLARE_FRAME_WND_CLASS(NULL, IDR_MAINFRAME)
    GLfloat m_fAngle;		// Rotation angle of the cube

    BEGIN_MSG_MAP(CMyOpenGLWnd)
        MESSAGE_HANDLER(WM_CREATE, OnCreate)
        CHAIN_MSG_MAP(CUpdateUI<CMyOpenGLWnd>)
        //CHAIN_MSG_MAP(CWindowImpl<CMyOpenGLWnd>)
        CHAIN_MSG_MAP(CFOpenGLWindowImpl<CMyOpenGLWnd>)
    END_MSG_MAP()

    BEGIN_UPDATE_UI_MAP(CMyOpenGLWnd)
    END_UPDATE_UI_MAP()
public:
    LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
    {
        // register object for message filtering and idle updates
        CMessageLoop* pLoop = _Module.GetMessageLoop();
        ATLASSERT(pLoop != NULL);
        //pLoop->AddMessageFilter(this);
        pLoop->AddIdleHandler(this);

        bHandled = FALSE;
        return 0;
    }

    //virtual BOOL PreTranslateMessage(MSG* pMsg)
    //{
    //    return CWindowImpl<CMyOpenGLWnd>::PreTranslateMessage(pMsg);
    //    //return FALSE;
    //}
    virtual BOOL OnIdle()
    {
        m_fAngle+= 1; // Add some rotation to the cube
        UpdateFPS();
        RedrawWindow();

        return TRUE;
    }
    BOOL OnInit(void) 
    {
        BOOL bRet = TRUE;
        GLenum glErr = GL_NO_ERROR;

        m_fAngle = 0.0f;
        OPENGL_VERIFY(glShadeModel(GL_SMOOTH));

        OPENGL_VERIFY(glClearColor(0.0f, 0.0f, 0.0f, 1.0f)); //Background color

        // Activate lighting and a light source
        OPENGL_VERIFY(glEnable(GL_LIGHT0));
        OPENGL_VERIFY(glEnable(GL_LIGHTING));
        OPENGL_VERIFY(glEnable(GL_DEPTH_TEST));

        // Define material parameters
        static GLfloat glfMatAmbient[] = {0.000f, 0.450f, 1.000f, 1.0f};
        static GLfloat glfMatDiffuse[] = {0.000f, 0.000f, 0.580f, 1.0f};
        static GLfloat glfMatSpecular[]= {1.000f, 1.000f, 1.000f, 1.0f};
        static GLfloat glfMatEmission[]= {0.000f, 0.000f, 0.000f, 1.0f};
        static GLfloat fShininess = 128.000f;

        // Set material parameters
        OPENGL_VERIFY(glMaterialfv(GL_FRONT, GL_AMBIENT,  glfMatAmbient));
        OPENGL_VERIFY(glMaterialfv(GL_FRONT, GL_DIFFUSE,  glfMatDiffuse));
        OPENGL_VERIFY(glMaterialfv(GL_FRONT, GL_SPECULAR, glfMatSpecular));
        OPENGL_VERIFY(glMaterialfv(GL_FRONT, GL_EMISSION, glfMatEmission));
        OPENGL_VERIFY(glMaterialf(GL_FRONT, GL_SHININESS, fShininess));

        return bRet;
    }

    BOOL OnRender(void)
    {
        BOOL bRet = TRUE;
        GLenum glErr = GL_NO_ERROR;
        OPENGL_VERIFY(glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)); // Clear buffers
        OPENGL_VERIFY(glLoadIdentity()); // Load identity matrix

        // Add a light source
        GLfloat glfLight[] = {-4.0f, 4.0f, 4.0f, 0.0f};
        OPENGL_VERIFY(glLightfv(GL_LIGHT0, GL_POSITION, glfLight));

        // Position and rotate the camera
        OPENGL_VERIFY(glTranslatef(0.0f, 0.0f, -5.0f));	
        OPENGL_VERIFY(glRotatef(30.0f, 1.0f, 0.0f, 0.0f));
        OPENGL_VERIFY(glRotatef(m_fAngle, 0.0f, 1.0f, 0.0f));

        // Draw a cube
        static GLfloat r = .7f;
        GLCube(-r, -r, -r, r, r, r);

        OPENGL_VERIFY(glFlush());

        return bRet;
    }

    BOOL OnResize(int cx, int cy) {
        GLfloat fFovy  = 30.0f; // Field-of-view
        GLfloat fZNear = 1.0f;  // Near clipping plane
        GLfloat fZFar = 10.0f;  // Far clipping plane

        // Calculate viewport aspect
        RECT rc;
        GetClientRect(&rc);

        GLfloat fAspect = (GLfloat)(rc.right-rc.left) / (GLfloat)(rc.bottom-rc.top);

        // Define viewport
        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        gluPerspective(fFovy, fAspect, fZNear, fZFar);
        glViewport(rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top);
        glMatrixMode(GL_MODELVIEW);

        return TRUE;
    }
    void UpdateFPS()
    {
        const int FRAMEINTERVAL = 1000;            // Show FPS every 1000th milliseconds
        static DWORD nFrames = 0;                  // Number of frames since last update
        static DWORD nLastTick = GetTickCount();   // Time of last update
        DWORD nTick = GetTickCount();              // Current time
        if(nTick-nLastTick>=FRAMEINTERVAL)
        {	
            float fFPS = 1000.0f*(GLfloat)nFrames/(GLfloat)(nTick-nLastTick);
            nLastTick = nTick;
            nFrames = 0;
            TCHAR szFPS[256];
            StringCchPrintf(szFPS, _countof(szFPS), TEXT("%.1f FPS"), fFPS);
            SetWindowText(szFPS);
        }
        nFrames++;
    }
    void GLCube(GLfloat x1, GLfloat y1, GLfloat z1, GLfloat x2, GLfloat y2, GLfloat z2)
    {
        glBegin(GL_POLYGON);
        glNormal3f(0.0f, 0.0f, 1.0f);
        glVertex3f(x2, y2, z2);
        glVertex3f(x1, y2, z2);
        glVertex3f(x1, y1, z2);
        glVertex3f(x2, y1, z2);
        glEnd();

        glBegin(GL_POLYGON);
        glNormal3f(0.0f, 0.0f, -1.0f);
        glVertex3f(x2, y2, z1);
        glVertex3f(x2, y1, z1);
        glVertex3f(x1, y1, z1);
        glVertex3f(x1, y2, z1);
        glEnd();

        glBegin(GL_POLYGON);
        glNormal3f(-1.0f, 0.0f, 0.0f);
        glVertex3f(x1, y2, z2);
        glVertex3f(x1, y2, z1);
        glVertex3f(x1, y1, z1);
        glVertex3f(x1, y1, z2);
        glEnd();

        glBegin(GL_POLYGON);
        glNormal3f(1.0f, 0.0f, 0.0f);
        glVertex3f(x2, y2, z2);
        glVertex3f(x2, y1, z2);
        glVertex3f(x2, y1, z1);
        glVertex3f(x2, y2, z1);
        glEnd();

        glBegin(GL_POLYGON);
        glNormal3f(0.0f, 1.0f, 0.0f);
        glVertex3f(x1, y2, z1);
        glVertex3f(x1, y2, z2);
        glVertex3f(x2, y2, z2);
        glVertex3f(x2, y2, z1);
        glEnd();

        glBegin(GL_POLYGON);
        glNormal3f(0.0f, -1.0f, 0.0f);
        glVertex3f(x1, y1, z1);
        glVertex3f(x2, y1, z1);
        glVertex3f(x2, y1, z2);
        glVertex3f(x1, y1, z2);
        glEnd();
    }

};

class CDlgFirst : 
    public ATL::CDialogImpl<CDlgFirst>,
	public CWinDataExchange<CDlgFirst>,
    public CDialogResizeEx<CDlgFirst>
{
public:
    
public:
    CDlgFirst();
	~CDlgFirst();
	enum { IDD = IDD_FIRST };

    BEGIN_MSG_MAP(CDlgFirst)
        //DUMP_WINDOWS_MSG(__FILE__LINE__, DEAFULT_DUMP_FILTER_MESSAGES, _countof(DEAFULT_DUMP_FILTER_MESSAGES), uMsg, wParam, lParam)

		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER_EX(IDC_BTN_BASIC_OPENGL, OnBasicOpenGLDemoWnd)

        CHAIN_MSG_MAP(CDialogResize<CDlgFirst>)
        REFLECT_NOTIFICATIONS()
    END_MSG_MAP()

	BEGIN_DDX_MAP(CDlgFirst)
	END_DDX_MAP()

    BEGIN_DLGRESIZE_MAP(CDlgFirst)
        //DLGRESIZE_CONTROL(IDOK, DLSZ_MOVE_X)
        //DLGRESIZE_CONTROL(IDCANCEL, DLSZ_MOVE_X)
        //DLGRESIZE_CONTROL(IDC_BTN_ST, DLSZ_MOVE_X)
        //DLGRESIZE_CONTROL(IDC_BTN_SHADE, DLSZ_MOVE_X)
    END_DLGRESIZE_MAP()

private:
    FTL::CFOpenGLApp     m_OpenGLApp;
    CMyOpenGLWnd    m_MyOpenGLWnd;
public:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    void OnBasicOpenGLDemoWnd(UINT uNotifyCode, int nID, CWindow wndCtl);
};


