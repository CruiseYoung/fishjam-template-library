Go -- 官网： https://code.google.com/p/go/
  特点：
    并发、支持垃圾回收(GC, 参见 gc1.go)、 适合多核机器、网络、Web开发
  环境搭建：
    1.环境变量: %GOROOT%=E:\Go\; %GOBIN%=C:\Go\Bin;  %GOARCH%=386|amd64;%GOOS%=mingw|windows;(实际上只要 GOROOT 即可 -- msi 安装程序只设置了这一个变量)
      将 %GOROOT%bin 加入 PATH 变量
      %GOPATH% -- 可指定各种package的路径(包括自定义package ?)
    2.命令行(cmd), 切到 %GOROOT%test 目录下，执行 "go run helloworld.go"
  IDE: -- .go 语言需要时 UTF-8 的编码方式，否则即使是注释也不能有中文等 
    1.Notepad++(5.6.8), 并安装 NppExec 插件( 插件 -> Plugin Manage -> Show Plugin Manager -> Available -> 选择"NppExec" 并 Install )
  语法 http://www.open-open.com/lib/view/open1352201112438.html
       http://www.open-open.com/lib/view/open1352264498172.html
    Go的正式的语法使用分号来终止语句，但这些分号由词法分析器在扫描源代码过程中使用简单的规则自动插入分号，源码中就不需要分号了。
      通常Go程序仅在for循环语句中使用分号，以此来分开初始化器、条件和增量单元
      注意：无论任何时候，你都不应该将一个控制结构（(if、for、switch或select）的左大括号放在下一行。如果这样做，将会在大括号的前方插入一个分号，这可能导致出现不想要的结果。
      没有 public/protected/private 的关键字，如果想让方法可以被别的包访问的话，第一个字母必须大写。
      
      
    package myPackageName
    import "fmt"
    func myFunName() {  //入口点需要是 main ?
      fmt.Printf("hello world")   //等价于  print("hello world")
      // return fmt.Sprintf("%d", 100); -- 可以返回格式化的string
    }
    
    1.var 变量名 [类型][= 初始值] 等价于 "变量名 := 初始值"
      go是静态类型的语言？语法很像 javascript(可不指明类型，通过初始化值来推导),
        常见类型有 bool, int, string 等
    2.for i := 0; i< 5; i++ { xxx } //for 语句没有括号 
    3.数组切片 // 类似 Python
    4.map --  m := make(map[string]int)  // string -> int 的映射, 然后 m["one']=1; delete(m, "one")
      也可以  m := map[string]int{"one": 1, "two": 2, "three": 3}
              for key, val := range m{ fmt.Printf("%s => %d\n", key, val)  
    5.指针 -- var pIntValue *int = &i
    内存分配
      new(T) -- 分配内存的内建函数, 只是将内存清零，而不是初始化内存，new(T)返回一个指向新分配的类型为T的零值的指针。
      make(T, args) -- 仅用于创建切片、map和chan（消息管道）,并返回类型T（不是*T）的一个被初始化了的（不是零）实例
        var v []int = make([]int, 10, 100) -- 分配一个整型数组，长度为10，容量为100，并返回前10个数组的切片
	6.内置类型?
        切片 -- 一个具有三项内容的描述符，包括指向数据（在一个数组内部）的指针、长度以及容量
    7.函数
      func 函数名(变量名 变量类型 , ...) 返回值 { 函数体 }
      返回多值 -- 很多函数都会返回两个值，一个正常值，一个是错误， 如：
        func multi_ret(key string)(int, bool) { var err bool; var val int; return val, err } 
        v, e := multi_ret("one")
        if v, e = multi_ret("four"); e { 正常返回 } else { 出错返回 } // 注意 if 的分号后面有 e
      函数不定参数 -- func sum(nums ...int)  for index, num := range nums { range 返回 下标,值 的多值 ? }
      函数闭包 -- 返回匿名函数的函数？ func nextNum() func() int { xxx := 100; return func() int { return xxx; }
    8.结构体
      type 结构体名 struct { xx1 类型;  xx2 类型 }
      type rect struct {  width, height int } func (r *rect) Area() int { return r.width * r.height }
    9.接口( type shape interface { 定义的方法原型， 如 Area() float64 }
      实现一个接口只需要定义和接口一样签名的方法，不需要从指定接口继承
      s := []shape{ &实例1, &实例2 } for _, sh := range s { xxxx } 
    10.错误处理 -- 内置的 error 接口，有一个 Error() string 方法
       defer -- 确保资源关闭(预设一个函数调用，在函数返回式自动执行， 类似 ResourceGuard ?)
       src, err := os.Open(srcFilePath);  defer src.Close(); 
       panic -- 不可恢复的错误,创建一个运行时错误并使程序停止，程序代码中应该避免
       recover -- 捕捉panic，必须在被 defer的函数内部才有效？ 在 panic 时重新获得Go程的控制权并恢复正常的执行
    11.并发 goroutine --  go 函数
    12.chanel -- 通信机制， 默认上是阻塞(类似生产者消费者队列)，可以用 select 来侦听多个channel
       channel := make(chan string)   //创建一个string类型的channel
       
  工具程序(go tool、gofmt、godoc、gofix) -- 为什么文档中有 8g 等，而我下载的就没有 -- 现在似乎统一成了 go.exe ?
    go.exe 
      build xxx.go [-o output] [build flags] [packages] -- 将 .go 文件编译成二进制文件，然后可直接运行
      run xxx.go -- 编译并运行 go 文件
      
<化学品环境风险防控“十二五”规划> , P11 - 癌症村
http://www.mep.gov.cn/gkml/hbb/bwj/201302/W020130220539067366659.pdf

异构开发(http://hc.csdn.net/) -- CPU + GPU

疯狂摩托车 笑尿了 
http://club.kdnet.net/dispbbs.asp?page=1&boardid=1&id=9221726

中国政法大学 非诚勿扰 -- http://www.tudou.com/programs/view/u-9O-3UOIjg/

graphics.TranslateTransform(dstRect.X + dstRect.Width / 2, dstRect.Y + dstRect.Height / 2);
 graphics.RotateTransform(m_rDegree); 

 Gdiplus::RectF rectTem=dstRect;
 rectTem.X = -dstRect.Width / 2;
 rectTem.Y = -dstRect.Height / 2;

 //反锯齿
 graphics.SetSmoothingMode(SmoothingModeHighQuality);
 graphics.DrawImage(m_pBitmap, rectTem, 0, 0, m_pBitmap->GetWidth(), m_pBitmap->GetHeight(), UnitPixel);
 Pen pen (Color(255, 255, 255, 255), 8);
 graphics.DrawRectangle(&pen, rectTem);
 graphics.ResetTransform();


模版中
嵌套依赖类型(http://leoxiang.com/dev/typename-and-nested-dependent-type-name-in-cpp)
  

Boost -- http://blog.csdn.net/caimouse/article/category/1339053/2
  1.lambda表达式，其实就是一个匿名函数。当你需要一个函数，并且只想使用一次时，但又不想声明这个函数，也不关心这个函数的名称，就可以使用这种表达方式。编译器自动生成该函数。好处是可以提高开发效率，提高类型安全，提供更加局部化的作用域代码。
  里面会有 _1, _2 这样的预定义变量？其他还有什么?
  注意：boost的lambda支持非常非常简陋，而支持C++ 0x的编译器 VS2010或者g++所支持的lambda则很好？
       #include <boost/lambda/lambda.hpp>   //将输入数字乘以3输出
       using namespace boost::lambda;
       typedef std::istream_iterator<int> in; 
       std::for_each(in(std::cin), in(), std::cout << (_1 * 3) <<" ");
等价于 std::for_each(in(std::cin), in(), CMyHandle());
       class CMyHandle{ void operator()(const int v){ std::cout << v  * 3 << " "; } };

函数操作对象 -- 有 operator()(xxx) 函数的类实例?

std::cin
  fail
  clear
  sync

tr1::shared_ptr, tr1::weak_ptr, tr1::function, tr1::bind




_WINDLL、_USRDLL(DLL工程)、
_ATL_DLL(链接 atl.lib, 运行时依赖 ATL.dll)
_DLL(CRT Dll version)
_AFXDLL(Use MFC in a Shared DLL)

Library\STL\STLTester 中可以加入 MFC CMap 等容器的测试
  map.InitHashTable(1031); //缺省是17
  GetStartPosition -> GetNextAssoc

尝试参考 CKeyEntry::SearchTermsMatch 和  CKademliaUDPListener::CreateSearchExpressionTree 写一个通用搜索?
  
WIN32;_WINDOWS;STRICT;_DEBUG
WIN32;_DEBUG;_WINDOWS;_USRDLL;FTLDLLPROJ_EXPORTS

.NET XML相关类(System.Xml)
  XmlTextWriter/XmlTextReader(序列读写，适合大文件) -- 像直接读写文本文件一样直接读取或写入XML文件。
  XmlDocument(随机定位并读写，使用方便，但只适合小文件) -- 将Xml视为内存中的对象集合，进行各种处理
    方法: Load/Save, CreateXxx, InsertXxx, AppendChild/PrependChild/RemoveChild, GetElementByXxx(搜索)
      遍历: foreach(XmlElement element in doc.DocumentElement.ChildNodes) { xxx; }
    相关类:XmlNode(NodeType区分) -> XmlElement/XmlAttribute/XmlComment/XmlDeclaration
  Web 中的 XmlDataSource -- Web中的数据源，以最简单的方式显示XML数据
  例:
     FileStream fs = new FileStream(filePath, FileMode.Create);
     XmlTextWriter xmlWriter = new XmlTextWriter(fs, null);
     xmlWriter.Formatting = Formatting.Indented; xmlWriter.Indentation = 4; //设置缩进的方式进行输出，否则会是一行，不便阅读
     xmlWriter.WriteStartDocument();
     xmlWriter.WriteStartElement("xxxx");  ....; xmlWriter.WriteEndElement();
     xmlWriter.EndDocument();
     xmlWriter.Close();
     fs.Close();  //?
Xml的高级搜索: XPath
XML名称空间(xmlns:前缀="URI") -- 核心思想是每一种XML标记语言都应该有一个自己的名称空间，用于标识此种标记语言之中的所有相关元素，
  用于消除不同XML标记语言中同名元素的歧义，通常使用URI(Universal Resource Identifiers)作为名称空间的名称，
XSD(XML Schema Definition, XML模式定义) -- 定义了XML文档必须遵循的XML文档结构规则，如哪些元素和属性可用、遵循的顺序、每一个元素的数据类型等。
  其名称空间是 xmlns:xsd="http://www.w3.org/2001/XMLSchema", 学习地址: http://www.w3school.com.cn/schema/
  1.每一个XSD必须以一个根元素<schema>开始;
  2.在 <schema> 中，通过 targetNamespace 属性来定义要验证目标XML文档的名称空间
XSL(eXtensible Stylesheet Language,可扩展样式语言) -- 用于搜索、格式化、转换XML文档的系列标准
  XSLT(XSL转换) -- 可以创建样式表，以便从一个较大的XML文档中抽取部分XML文档，常用于将XML文档装换为HTML文档
  .NET 使用: System.Xml.Xsl.XslCompiledTransform 对象

C#中验证XML文档(System.Xml.Schema) -- 创建内建Schema验证功能的XmlReader对象(ASP.NET 3.5从入门到精通，P644)
  XmlSchema
  XmlShcemaCollection --

XML序列化 -- 可以将XML文件中的信息取出，并填充到一个已经创建好的自定义类中。
LINQ to XML -- 
XmlDataDocument -- 融合了 XmlDocument + DataSet,可以同时以两种不同的方式来查看数据

//静态链接Vista中的哭，并使用 delayload 的方式放置在WinXp等上无法运行
#pragma comment(lib, "dwmapi.lib")
#pragma comment(lib, "delayimp.lib")
#pragma comment(linker, "/delayload:dwmapi.dll")

http://companyadc.51job.com/companyads/2013/cd/shilian0301_8788wh/index.htm
wxWidget -- http://www.wxwidgets.org/, C++ 的跨平台UI库

C方式往命令行上输出二进制：
 _setmode(_fileno(stdout), _O_BINARY);
 fwrite(pBuff, 1, cbCount, stdout);

123 -- 07fishjamaaabdCdigaBBffdaahFaagbaaaEaahFaafEaafFaaedaacAaaciaafeaafiaaeFaafhaafAaadaaafBaafcaafhaafD

C#中调试: System.Diagnostics.Trace.Write
Encoding.UTF8.GetBytes(content);  将字符串content变为字节形式(网络发送)
多线程同步 Mutex，Monitor，Interlocked和AutoResetEvent，简化的 lock， CountdownEvent ?
  线程池： ThreadPool.QueueUserWorkItem(new WaitCallback(helper.DoTransactions));
    .NET 4 中: System.Threading.Tasks 命名空间，用于并行计算，其中有 Parallel(Invoke/for/forEach)、Task 等类
   Parallel.For(0, 20000000, i =>
   {
     bag.Add(i);
   });
   并行计算时的异常是 AggregateExcepation(可通过 foreach 获取其中的每个异常)
	var task1 = new Task(() =>
	{
	  Run1();   //创建 task1 后，还需要 task1.Start 才能运行
	});
	var task2 = Task.Factory.StartNew(() =>
	{
       Run2();  //创建 task2 后，已经自动运行
    });

  Stopwatch watch = Stopwatch.StartNew();  watch.Elapsed; //测试花费时间的？
  
  //每个线程下载的字节数，方便最后合并
  public static ConcurrentDictionary<long, byte[]> dic = new ConcurrentDictionary<long, byte[]>();          


内存泄漏
  1.MFC 的 
#define new				DEBUG_NEW
#define malloc( param_size_t )		_malloc_dbg(param_size_t, _NORMAL_BLOCK, __FILE__, __LINE__)
#define free( param_ptr )			_free_dbg(param_ptr, _NORMAL_BLOCK)

注意：
  自动构造和析构全局和静态对象需要链接CRT，但这正是建立局域ATL的COM服务器经常要回避的地方
  CRT -- C++异常、全局对象的初始化和终止化
   
ATL的多步骤构造 -- 方便进行错误处理
  new() -- 构造函数，Construct
  CComObjectRootBase::FinalConstruct -- 可在其中进行可能会失败的调用，并返回结果。
    当重载该方法时，需要声明 DECLARE_PROTECT_FINAL_CONSTRUCT 宏(保证调用 FinalConstruct 时引用计数不为0 )
  FinalRelease -- ATL对象最后一个接口引用被释放后，析构函数调用前，会调用这个函数
  
_declspec(novtbl) -- 禁止构造期间对vptr进行调整， ATL_NO_VTBL 宏
   
high-dpi -- http://technet.microsoft.com/zh-cn/library/dd464646 

Chrome : eclipse + JavaScript Plugin
a. 中文 http://open.chrome.360.cn/extension_dev/overview.html
b. 英文 https://sites.google.com/site/crxdoczh/reference/api_index/extension  （需要使用代理访问）
c. JavaScript，Html，CSS , JQuery http://www.w3school.com.cn/

TODO: 
  1.写 CComBSTR/CComVariant 的UT
  2.通过类型库进行ComDetect?
  3.CComPtr<IShellBrowser>  spShellBrowser; 比较 if (NULL == spShellBrowser) if(spShellBrowser == NULL) 的区别
    据说不能编译，但VC2008中OK
  4.查聚合相关的源码和Demo程序 -- m_pUnkOuter、CComObjectRootBase::OuterAddRef 等，

说明性编译标示符(declspec, declarative specifier), 如 struct __declspec(uuid("xxxxxx")) IUnknown {...};
  然后可以使用 __uuidof 操作符来得到一个类型的UUID

BitBlt 的 CAPTUREBLT

C运行时本地语言设置(runtime locale setting) -- 如 wcscmp 缺省时仅比较52个不带重音的字母字符，
  要想使用操作系统的本地设置来比较字符串，必须调用 setlocale(LC_ALL, "");

C++语言定义bool数据类型是一个8位的值(0或者1)， BOOL 是long(32/64位)的
  
    
全局变量：
  _AtlBaseModule
  
字符类型(ANSI/Unicode) + 字符集()
  ANSI(也称为 SBCS -- Single-Byte Character Set)
  UNICODE
  EBCDIC(Extended Binary Coded Decimal Interchange Code) -- IBM推出的，通常用于大型机
  MBCS/DBCS(Multi/Double -Byte Character Set) -- 多/双字节字符集，混合长度的字符集，有些字符由多个字节组成，
    Win9x使用，DBCS是MBCS的一种特殊类型(有些字符由两个字节组成，表示一个指定地区的符号，如 中日韩)
    在VC6中，MBCS总是意味着DBCS(它不支持超过两个字节的字符集)
注意：ANSI字符是有符号的(char)，MBCS字符是无符号的(unsigned char) -- ANSI字符的表达式取值和使用MBCS字符的不同

ATL字符串转换宏(如 T2W，T2BSTR 等)
  当源字符集和目的字符集不同并且目的类型不是BSTR时，会使用运行库函数 _alloca 在栈上分配内存，因此：
    1.不要在循环中使用
    2.当目的类型是BSTR时，会使用 SysAllocString 和 SysAllocStringLen 函数来分配目标字符串，必须使用 
      SysFreeString 显示地释放
  但 CT2W 等宏似乎没有这个问题了?
  ATL::ocscpy -- 拷贝 OLESTR 字符串，而不要用 lstrcpyW(Win9X上没有实现)， 对应的有 ocslen/CharNextO 等

多线程模型(向导)
  Apartment -- 无需同步对实例数据的访问就能保护对象，但这个类的对象可在不同的STA中被创建，所以静态和全局数据仍然需要同步。
  Free -- 这个类的对象只能存在于MTA中(如果没有，系统会自动创建一个，并自动同步？)在MTA中的对象必须同步对实例、全局数据的访问
  Both -- 希望共享客户套间的对象可把他们的类标记为Both，意味着没有不兼容的线程模型。当想避免代理/存根开销的时候可以使用这个值。
    
MMC(Microsoft Management Console) -- 微软管理控制台。可以写 extensions(扩展) ?

IDispatch中对于TypeLib的手动实现(即 IDispatchImpl 的实现方式 ?)
  a.构造中从注册信息中获得 ITypeInfo指针的成员变量 m_pTypeInfo， 在IDispatch的方法实现中即可调用该接口实现
    IID*		pIID = &IID_IPenguin;
    GUID*		pLibID = &LIBID_BIRDSERVERLib;
    WORD		wMajor = 1;
    WORD		wMinor = 0;
    ITypeLib* pTl = NULL;
    HRESULT hr = LoadRegTypeLib(*pLibID, wMajor, wMinor, 0, &pTl);
    if(SUCCEEDED(hr))
    {  hr = pTl->GetTypeInfoOfGuid(*pIID, &m_pTypeInfo); pTl->Release(); }
  b.GetTypeInfoCount 函数返回 1;
  c.GetTypeInfo 中 
    { 
      if ctInfo != 0; { *ppti= NULL; return DISP_E_BADINDEX; }
      *ppti = m_pTypeInfo; m_pTypeInfo->AddRef(); return S_OK;
    }

CComObjectRootBase::InternalQueryInterface -- 静态函数，对于被请求的接口，用一个指向适当VPTR(virtual function table pointer虚函数表指针)
  的指针来填充参数 ppvObject 返回，

CComObject -- 用于独立对象
CComAggObject -- 用于聚合对象
CComPolyObject -- 可以同时支持 独立或被聚合对象(可以节省一套vtbl) ?在CreateInstance实现中
  *ppv = 0; CComPolyObject<CMyClass>* pObj = new CComPolyObject<CMyClass>(pUnkOuter);
CComObjectCached -- 用于创建一个在整个服务器生命周期中存在的实例，通常可用于进程内的全局的全局变量
CComObjectNoLock -- 对象的存在不影响服务器的生命周期(即不会调用 _Module.Lock 一类的函数)
CComObjectGlobal -- 对象的生命周期等同于服务器的生命周期，通常用于全局或静态对象。在实现进程内类对象时，全局对象可以替代缓冲对象使用。
CComObjectStack -- 在栈上分配一个COM对象， 如 CComObjectStack<CMyClass> myObject; myObject.xxxx();


ATL创建者(Creator) -- 有静态的CreateInstance函数
  CComCreator -- 既可创建独立实例又可创建聚合实例的创建者，模板参数是被创建的C++类
    typedef CComCreator<CComPolyObject<CMyClass> > MyClassPolyCreator; MyClassPolyCreator::CreateInstance(pUnkOuter, riid, ppv);
  

CoRegisterClassObject <--> CoRevokeClassObject

AVI Mux 中写入属性
   http://en.wikipedia.org/wiki/Resource_Interchange_File_Format
   http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/RIFF.html
 CComQIPtr<IPersistMediaPropertyBag> pPersist;
 CComPtr<IMediaPropertyBag> pBag;
 VARIANT val; 
 // Query the AVI Mux filter for IPersistMediaPropertyBag (not shown).
 pPersist = m_spMuxFilter;
 CoCreateInstance(CLSID_MediaPropertyBag, NULL, CLSCTX_INPROC, IID_IMediaPropertyBag, (LPVOID *)&pBag);
 val.vt = VT_BSTR;
 val.bstrVal = SysAllocString(OLESTR("MyProperty"));
 pBag->Write(OLESTR("INFO/IART"), &val);  //RIFFINFO_IART
 pPersist->Load(pBag, NULL);
 VariantClear(&val);
  
  
Implement Interface wizard(实现接口向导) -- 实现类型库(TypeLib)中已有定义的接口
连接点：为了使脚本客户(如IE)接收事件，对象需要从 IProvideClassInfo2Impl 继承，对应接口允许客户查询对象的
        缺省接口标识符(default interface identifier),然后用它通过 IConnectPointContainer 接口建立联系

IViewObjectExImpl -- 

不能使用CComBSTR代替BSTR的场景：？
CComVariant

UI
  向导生成的对话框从 CAxDialogImpl 派生,

组件类别(使用 BEGIN_CATEGORY_MAP/END_CATEGORY_MAP 声明 )
  CATID_SafeForScripting -- 安全脚本
  CATID_SafeForInitializing -- 安全初始化，有什么用？

//DShow中的音量控制转换, 底层的 -10000~0 <==> 0%~100%
	long CalcVolumeToPercent(long lVolume)
	{
		long nVolumePercent = (long)pow(10, (2.0 * double(lVolume + 10000) / 10000.0));

		return nVolumePercent;
	}

	long CalcPercentToVolume(long lVolumePercent)
	{
		long nVolume = -10000;
		if (0 != lVolumePercent)
		{
			nVolume = (long)((10000.0 * log10((double)lVolumePercent) / 2.0) - 10000);
		}
		return nVolume;
	}

docfileview http://blog.tinybrowser.net/archives/442
视频解码器和render之间增加一个内容透传的filter，需要处理颜色空间的差异及显卡内存自动对齐问题
  http://bbs.csdn.net/topics/340218555

http://wenku.baidu.com/view/6243ee2f2af90242a895e555.html

1.Intel Media SDK
  http://software.intel.com/en-us/articles/intel-media-software-development-kit-intel-media-sdk/
  支持 H.264 和 MPEG-2 格式编码,提供了 Encoder/Decoder Filter
  支持Intel显卡的硬编码
  授权协议： 免费，非开源
  问题：
     1.目前尚未测试通过(不能生成文件)， 需要进一步研究测试。
     2.发布时需要包含Intel Media SDK相关的文件(有一个 11.5M的 libmfxsw32.dll, 使用最高压缩比的ZIP压缩后为 3.6M)
  
2.Media Foundation
  http://msdn.microsoft.com/library/windows/desktop/dd757927(v=vs.85).aspx
  支持 H264 Video Encoder
  授权协议：Windows自带，但 需要 Windows 7 OS
  其他：Snagit 11 Video Record 在 Windows7 的实现似乎就是这种方式
  
  
	static const GUID CLSID_H264EncMs = 
	{ 0x6ca50344, 0x051a, 0x4ded, { 0x97, 0x79, 0xa4, 0x33, 0x05, 0x16, 0x5e, 0x35 } };

	CComPtr<IUnknown> spUnknown;
	COM_VERIFY(CoCreateInstance(CLSID_H264EncMs, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (LPVOID*)&spUnknown));
	if (spUnknown)
	{
		COM_VERIFY(spUnknown->QueryInterface(IID_IMFTransform, (void**)&m_spTransformH264));
	}
	VIDEOINFOHEADER* pHeader = NULL;

	//{98230571-0087-4204-b020-3282538e57d3}
	static const GUID CLISD_ColorConvertDMO = 
	{ 0x98230571, 0x0087, 0x4204, { 0xb0, 0x20, 0x32, 0x82, 0x53, 0x8e, 0x57, 0xd3 } };
	CComPtr<IUnknown> spColorConvertDMO;
	COM_VERIFY(CoCreateInstance(CLISD_ColorConvertDMO, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (LPVOID*)&spColorConvertDMO));
	if (spColorConvertDMO)

http://www.fishlee.net/soft/44/download.html




void bin_dump( LPCSTR pData, int len )
{
	if( len <= 0 )
		return;

	int nTotalSize = 1024 + (len * 4) + (len/10 * 64) + 1;
	char *pBuffer = (char*)malloc( nTotalSize );
	if( pBuffer == NULL )
		return;
	int nCurrSize = 0;
	pBuffer[0] = '\0';

	nCurrSize += _snprintf(pBuffer+nCurrSize, nTotalSize-nCurrSize, 
		"\r\n[DUMP BIN BEGIN] pData=%p, len=%d---------------------------------\r\n", pData, len );

	const int ONE_LINE_COUNT	= 20;

	nCurrSize += _snprintf(pBuffer+nCurrSize, nTotalSize-nCurrSize, 
		"\t%c\t", '/' );

	for( int i=0 ; i < ONE_LINE_COUNT ; i++ )
	{
		nCurrSize += _snprintf(pBuffer+nCurrSize, nTotalSize-nCurrSize, " %2d", i );
	}

	nCurrSize += _snprintf(pBuffer+nCurrSize, nTotalSize-nCurrSize, "\r\n" );

	int nLineCount = (len-1) / ONE_LINE_COUNT + 1;

	for( int i=0 ; i < nLineCount ; i++ )
	{
		nCurrSize += _snprintf(pBuffer+nCurrSize, nTotalSize-nCurrSize, "\t%d\t", i );

		int nLineEnd = ONE_LINE_COUNT;
		
		if( i == nLineCount - 1 )
		{
			nLineEnd = len % ONE_LINE_COUNT;
			if( nLineEnd == 0 )
				nLineEnd = ONE_LINE_COUNT;
		}

		int j;
		for( j=0 ; j < nLineEnd ; j++ )
		{
			int n = (pData[i*ONE_LINE_COUNT + j] & 0x000000ff);
			nCurrSize += _snprintf(pBuffer+nCurrSize, nTotalSize-nCurrSize, " %02X", n );
		}

		for( ; j < ONE_LINE_COUNT ; j++ )
		{
			nCurrSize += _snprintf(pBuffer+nCurrSize, nTotalSize-nCurrSize, "   " );
		}

		nCurrSize += _snprintf(pBuffer+nCurrSize, nTotalSize-nCurrSize, "         [" );

		for( j=0 ; j < nLineEnd ; j++ )
		{
			nCurrSize += _snprintf(pBuffer+nCurrSize, nTotalSize-nCurrSize, "%c", pData[i*ONE_LINE_COUNT + j] );
		}

		nCurrSize += _snprintf(pBuffer+nCurrSize, nTotalSize-nCurrSize, "]\r\n" );
	}

	nCurrSize += _snprintf(pBuffer+nCurrSize, nTotalSize-nCurrSize, "[DUMP BIN END] pData=%p, len=%d---------------------------------\r\n", pData, len );

#if defined(WIN32)
	WRITE_DEBUG_LOG( "%s", pBuffer );
#endif
	free(pBuffer);
}

//FillDisk
void CMainDlg::OnStartFill(UINT uNotifyCode, int nID, CWindow wndCtl)
{
	HRESULT hr = E_FAIL;
	CAtlFile file;
	DoDataExchange(TRUE);

	if (m_nFileSize < m_nMaxSize)
	{
		COM_VERIFY(file.Create(m_strFilePath, FILE_ALL_ACCESS|GENERIC_WRITE,
			0, CREATE_ALWAYS));
		if (SUCCEEDED(hr))
		{
			LONGLONG llFileSize = (LONGLONG)m_nFileSize * 1024 * 1024;
			COM_VERIFY(file.SetSize( llFileSize - sizeof(DWORD)));
			if (SUCCEEDED(hr))
			{
				//DWORD dwFill = 0x12345678;
				//COM_VERIFY(file.Seek(-sizeof(dwFill), FILE_END));
				//COM_VERIFY(file.Write(&dwFill, sizeof(dwFill)));
			}
			file.Close();
		}
	}
}


Java程序优化
  1.I/O 操作较慢，是一个很耗时的操作，可考虑减少IO(如减少日志)的方式大幅提升
  2.DB优化
    a.共享数据库连接 -- 如系统提供的?Database Connection Pool 
    b.使用预编译 SQL -- 使用 java.sql.PreparedStatement 代替 java.sql.Statement 生成 SQL 语句
    c.使用 SQL 批处理 -- 通过 java.sql.PreparedStatement 的 addBatch 方法将 SQL 语句加入到批处理