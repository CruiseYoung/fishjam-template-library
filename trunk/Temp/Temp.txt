high-dpi -- http://technet.microsoft.com/zh-cn/library/dd464646 

TODO: 
  1.写 CComBSTR/CComVariant 的UT
  2.通过类型库进行ComDetect?
  3.CComPtr<IShellBrowser>  spShellBrowser; 比较 if (NULL == spShellBrowser) if(spShellBrowser == NULL) 的区别
    据说不能编译，但VC2008中OK
  4.查聚合相关的源码和Demo程序 -- m_pUnkOuter、CComObjectRootBase::OuterAddRef 等，

说明性编译标示符(declspec, declarative specifier), 如 struct __declspec(uuid("xxxxxx")) IUnknown {...};
  然后可以使用 __uuidof 操作符来得到一个类型的UUID

BitBlt 的 CAPTUREBLT

C运行时本地语言设置(runtime locale setting) -- 如 wcscmp 缺省时仅比较52个不带重音的字母字符，
  要想使用操作系统的本地设置来比较字符串，必须调用 setlocale(LC_ALL, "");

C++语言定义bool数据类型是一个8位的值(0或者1)， BOOL 是long(32/64位)的
  
    
全局变量：
  _pModule(在 CComModule::Init 中初始化) 变量，就不需要再定义 ftlWindow.h 中的 ATL对象了 ?
  _AtlBaseModule
  
字符类型(ANSI/Unicode) + 字符集()
  ANSI(也称为 SBCS -- Single-Byte Character Set)
  UNICODE
  EBCDIC(Extended Binary Coded Decimal Interchange Code) -- IBM推出的，通常用于大型机
  MBCS/DBCS(Multi/Double -Byte Character Set) -- 多/双字节字符集，混合长度的字符集，有些字符由多个字节组成，
    Win9x使用，DBCS是MBCS的一种特殊类型(有些字符由两个字节组成，表示一个指定地区的符号，如 中日韩)
    在VC6中，MBCS总是意味着DBCS(它不支持超过两个字节的字符集)
注意：ANSI字符是有符号的(char)，MBCS字符是无符号的(unsigned char) -- ANSI字符的表达式取值和使用MBCS字符的不同

ATL字符串转换宏(如 T2W，T2BSTR 等)
  当源字符集和目的字符集不同并且目的类型不是BSTR时，会使用运行库函数 _alloca 在栈上分配内存，因此：
    1.不要在循环中使用
    2.当目的类型是BSTR时，会使用 SysAllocString 和 SysAllocStringLen 函数来分配目标字符串，必须使用 
      SysFreeString 显示地释放
  但 CT2W 等宏似乎没有这个问题了?
  ATL::ocscpy -- 拷贝 OLESTR 字符串，而不要用 lstrcpyW(Win9X上没有实现)， 对应的有 ocslen/CharNextO 等

多线程模型(向导)
  Apartment -- 无需同步对实例数据的访问就能保护对象，但这个类的对象可在不同的STA中被创建，所以静态和全局数据仍然需要同步。
  Free -- 这个类的对象只能存在于MTA中(如果没有，系统会自动创建一个，并自动同步？)在MTA中的对象必须同步对实例、全局数据的访问
  Both -- 希望共享客户套间的对象可把他们的类标记为Both，意味着没有不兼容的线程模型。当想避免代理/存根开销的时候可以使用这个值。
    
MMC(Microsoft Management Console) -- 微软管理控制台。可以写 extensions(扩展) ?

IDispatch中对于TypeLib的手动实现(即 IDispatchImpl 的实现方式 ?)
  a.构造中从注册信息中获得 ITypeInfo指针的成员变量 m_pTypeInfo， 在IDispatch的方法实现中即可调用该接口实现
    IID*		pIID = &IID_IPenguin;
    GUID*		pLibID = &LIBID_BIRDSERVERLib;
    WORD		wMajor = 1;
    WORD		wMinor = 0;
    ITypeLib* pTl = NULL;
    HRESULT hr = LoadRegTypeLib(*pLibID, wMajor, wMinor, 0, &pTl);
    if(SUCCEEDED(hr))
    {  hr = pTl->GetTypeInfoOfGuid(*pIID, &m_pTypeInfo); pTl->Release(); }
  b.GetTypeInfoCount 函数返回 1;
  c.GetTypeInfo 中 
    { 
      if ctInfo != 0; { *ppti= NULL; return DISP_E_BADINDEX; }
      *ppti = m_pTypeInfo; m_pTypeInfo->AddRef(); return S_OK;
    }



CComObjectRootBase::InternalQueryInterface -- 静态函数，对于被请求的接口，用一个指向适当VPTR(virtual function table pointer虚函数表指针)
  的指针来填充参数 ppvObject 返回，

AVI Mux 中写入属性
   http://en.wikipedia.org/wiki/Resource_Interchange_File_Format
   http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/RIFF.html
 CComQIPtr<IPersistMediaPropertyBag> pPersist;
 CComPtr<IMediaPropertyBag> pBag;
 VARIANT val; 
 // Query the AVI Mux filter for IPersistMediaPropertyBag (not shown).
 pPersist = m_spMuxFilter;
 CoCreateInstance(CLSID_MediaPropertyBag, NULL, CLSCTX_INPROC, IID_IMediaPropertyBag, (LPVOID *)&pBag);
 val.vt = VT_BSTR;
 val.bstrVal = SysAllocString(OLESTR("MyProperty"));
 pBag->Write(OLESTR("INFO/IART"), &val);  //RIFFINFO_IART
 pPersist->Load(pBag, NULL);
 VariantClear(&val);
  
  
Implement Interface wizard(实现接口向导) -- 实现类型库(TypeLib)中已有定义的接口
连接点：为了使脚本客户(如IE)接收事件，对象需要从 IProvideClassInfo2Impl 继承，对应接口允许客户查询对象的
        缺省接口标识符(default interface identifier),然后用它通过 IConnectPointContainer 接口建立联系

IViewObjectExImpl -- 

不能使用CComBSTR代替BSTR的场景：？
CComVariant

UI
  向导生成的对话框从 CAxDialogImpl 派生,

组件类别(使用 BEGIN_CATEGORY_MAP/END_CATEGORY_MAP 声明 )
  CATID_SafeForScripting -- 安全脚本
  CATID_SafeForInitializing -- 安全初始化，有什么用？

docfileview http://blog.tinybrowser.net/archives/442
视频解码器和render之间增加一个内容透传的filter，需要处理颜色空间的差异及显卡内存自动对齐问题
  http://bbs.csdn.net/topics/340218555

http://wenku.baidu.com/view/6243ee2f2af90242a895e555.html

1.Intel Media SDK
  http://software.intel.com/en-us/articles/intel-media-software-development-kit-intel-media-sdk/
  支持 H.264 和 MPEG-2 格式编码,提供了 Encoder/Decoder Filter
  支持Intel显卡的硬编码
  授权协议： 免费，非开源
  问题：
     1.目前尚未测试通过(不能生成文件)， 需要进一步研究测试。
     2.发布时需要包含Intel Media SDK相关的文件(有一个 11.5M的 libmfxsw32.dll, 使用最高压缩比的ZIP压缩后为 3.6M)
  
2.Media Foundation
  http://msdn.microsoft.com/library/windows/desktop/dd757927(v=vs.85).aspx
  支持 H264 Video Encoder
  授权协议：Windows自带，但 需要 Windows 7 OS
  其他：Snagit 11 Video Record 在 Windows7 的实现似乎就是这种方式
  
  
	static const GUID CLSID_H264EncMs = 
	{ 0x6ca50344, 0x051a, 0x4ded, { 0x97, 0x79, 0xa4, 0x33, 0x05, 0x16, 0x5e, 0x35 } };

	CComPtr<IUnknown> spUnknown;
	COM_VERIFY(CoCreateInstance(CLSID_H264EncMs, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (LPVOID*)&spUnknown));
	if (spUnknown)
	{
		COM_VERIFY(spUnknown->QueryInterface(IID_IMFTransform, (void**)&m_spTransformH264));
	}
	VIDEOINFOHEADER* pHeader = NULL;

	//{98230571-0087-4204-b020-3282538e57d3}
	static const GUID CLISD_ColorConvertDMO = 
	{ 0x98230571, 0x0087, 0x4204, { 0xb0, 0x20, 0x32, 0x82, 0x53, 0x8e, 0x57, 0xd3 } };
	CComPtr<IUnknown> spColorConvertDMO;
	COM_VERIFY(CoCreateInstance(CLISD_ColorConvertDMO, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (LPVOID*)&spColorConvertDMO));
	if (spColorConvertDMO)
