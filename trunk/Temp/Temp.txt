TODO: 
  通过类型库进行ComDetect?
  ComStudy 中增加 IConnectionPointContainerImpl 的描述 -- 连接点容器基本实现，支持查找和枚举连接点
  Html中使用COM: <object classid="clsid:xxxx-bbbb-ddd" id=objName> 
                    <param name=xxxx value=100>
                 </object>
                 <input type=button name=cmdTest value="test">
                 <script language=vbscript> 
                   sub .cmdTest_onClick 
                     objName.xxxx = 100
                   end sub
                   sub objName._onXXX(value)
                      //脚本中处理连接点激发的事件 -- 对象需要实现 IProvideClassInfo2 接口
                   end sub 
                 </script>
   属性的持续性=>更名为"持久化"; 
   只要从 IPersistStreamInitImpl、IPersistStorageImpl、IPersistPropertyBagImpl 三个接口实现中任意一个继承，
     并且增加名为 m_bRequiresSave 的成员变量，再把接口添加到 COM_MAP 中，COM对象就支持持久化
     -- 自动对对象属性表(PROP_MAP)中的数据进行持久化
   
ATL
ATL通过大量的 IxxxImpl 接口实现模板类提供接口的基本实现和扩展 --
ProgID -- Programmatic identifier，和版本无关的程序标识符，
  版本相关的ProgID由版本无关的ProgID加后缀(如 ".1" 组成)
向导中
  线程模型将决定进程内服务器自注册设置中的ThreadingModel值，同时也决定了对象AddRef和Release方法的实现需要怎样的线程安全性
  聚合 -- 对象是否能够作为受控的内部对象参与聚合，不影响类的对象是否能作为外部控制对象使用聚合？
  ISupportErrorInfo -- 通过COM异常(错误信息对象)传递的细节错误信息比单独一个HRESULT所能提供的信息更多。
    COM的错误处理？ATL::CComCoClass::Error(L"提示信息", ...);
  连接点 -- 用于向它的容器激发事件
  Free Threaded Marshaler(FTM) -- Tooltip中所说的太夸大(创建一个自由线程列集器对象，能有效地在同一个进程的不同线程之间列集接口指针)

骗出ATL对象向导(如在Win32程序中加入COM对象)，要求：
  1.必须是DLL或Win32应用 -- 非控制台
  2.<project>.cpp 文件中必须有 BEGIN_OBJECT_MAP(ObjectMap) .... END_OBJECT_MAP()
    但新的映射方式已经更改为 OBJECT_ENTRY_AUTO ?
  3.工程中必须有 <project>.idl 文件,且最下面必须有 library xxxx { ... }
CComBSTR bstrText = OLESTR("xxxx"); OLE2CT(bstrXXX);
Implement Interface wizard(实现接口向导) -- 实现类型库(TypeLib)中已有定义的接口
连接点：为了使脚本客户(如IE)接收事件，对象需要从 IProvideClassInfo2Impl 继承，对应接口允许客户查询对象的
        缺省接口标识符(default interface identifier),然后用它通过 IConnectPointContainer 接口建立联系





docfileview http://blog.tinybrowser.net/archives/442
视频解码器和render之间增加一个内容透传的filter，需要处理颜色空间的差异及显卡内存自动对齐问题
  http://bbs.csdn.net/topics/340218555

http://wenku.baidu.com/view/6243ee2f2af90242a895e555.html

1.Intel Media SDK
  http://software.intel.com/en-us/articles/intel-media-software-development-kit-intel-media-sdk/
  支持 H.264 和 MPEG-2 格式编码,提供了 Encoder/Decoder Filter
  支持Intel显卡的硬编码
  授权协议： 免费，非开源
  问题：
     1.目前尚未测试通过(不能生成文件)， 需要进一步研究测试。
     2.发布时需要包含Intel Media SDK相关的文件(有一个 11.5M的 libmfxsw32.dll, 使用最高压缩比的ZIP压缩后为 3.6M)
  
2.Media Foundation
  http://msdn.microsoft.com/library/windows/desktop/dd757927(v=vs.85).aspx
  支持 H264 Video Encoder
  授权协议：Windows自带，但 需要 Windows 7 OS
  其他：Snagit 11 Video Record 在 Windows7 的实现似乎就是这种方式
  
  
	static const GUID CLSID_H264EncMs = 
	{ 0x6ca50344, 0x051a, 0x4ded, { 0x97, 0x79, 0xa4, 0x33, 0x05, 0x16, 0x5e, 0x35 } };

	CComPtr<IUnknown> spUnknown;
	COM_VERIFY(CoCreateInstance(CLSID_H264EncMs, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (LPVOID*)&spUnknown));
	if (spUnknown)
	{
		COM_VERIFY(spUnknown->QueryInterface(IID_IMFTransform, (void**)&m_spTransformH264));
	}
	VIDEOINFOHEADER* pHeader = NULL;

	//{98230571-0087-4204-b020-3282538e57d3}
	static const GUID CLISD_ColorConvertDMO = 
	{ 0x98230571, 0x0087, 0x4204, { 0xb0, 0x20, 0x32, 0x82, 0x53, 0x8e, 0x57, 0xd3 } };
	CComPtr<IUnknown> spColorConvertDMO;
	COM_VERIFY(CoCreateInstance(CLISD_ColorConvertDMO, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (LPVOID*)&spColorConvertDMO));
	if (spColorConvertDMO)
